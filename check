public class FixRulesBuilder extends FixRulesBaseListener {

    private Stack<GroovyRuleBuilder> ifStack;

    private List<GroovyRuleBuilder> andStack;
    private List<GroovyRuleBuilder> orStack;

    private GroovyRuleBuilder builder;
    private GroovyTag tag;
    List<Condition> conditions = new ArrayList<>();
    private List<RuleBuilder> ruleBuilders;

    @Override
    public void enterRules(FixRulesParser.RulesContext ctx) {
        ruleBuilders = new ArrayList<>();
    }

    @Override
    public void enterAbsent(FixRulesParser.AbsentContext ctx) {
        builder.getAbsent();
    }

    @Override
    public void enterPresent(FixRulesParser.PresentContext ctx) {
        builder.addCondition(IS_PRESENT);
    }

    @Override
    public void enterAnd(FixRulesParser.AndContext ctx) {
        if (andStack == null) andStack = new ArrayList<>(5);

        andStack.add(builder);
        builder.getAnd();
    }

    @Override
    public void enterMandatory(FixRulesParser.MandatoryContext ctx) {
        builder.getMandatory();
    }

    @Override
    public void enterNumeric(FixRulesParser.NumericContext ctx) {
        builder.getNumeric();
    }

    @Override
    public void enterAlphanumeric(FixRulesParser.AlphanumericContext ctx) {
        builder.getNumeric();
    }

    @Override
    public void enterEveryRule(ParserRuleContext ctx) {
        //System.out.println("enterEveryRule: " + ctx.getText());
    }

    @Override
    public void enterList(FixRulesParser.ListContext ctx) {
        String listOperand = ctx.getText();
        String listOperator = ctx.getParent().getChild(0).getText();

        listOperand = listOperand.replaceAll("\\[|\\]|\"", "");
        String[] listOperands = listOperand.split(Patterns.COMMA_SEPARATOR);

        switch (listOperator) {
            case "not in":
                builder.addCondition(new NotCondition(new ContainsCondition(listOperands)));
                break;
            case "in":
                builder.oneOf(listOperands);
                break;
            default:
                System.out.println("unrecognized list operator: " + listOperator);
        }
    }

    @Override
    public void enterListOperator(FixRulesParser.ListOperatorContext ctx) {
        String listOperator = ctx.getText();
    }

    @Override
    public void enterBiOperand(FixRulesParser.BiOperandContext ctx) {
        String text = ctx.getText();
        text = text.replaceAll("\\)|\\(", "");

        String[] operands = text.split(Patterns.COMMA_SEPARATOR);
        if (operands != null && operands.length == 2) {
            String op1 = operands[0];
            String op2 = operands[1];

            builder.addCondition(new BetweenCondition(Double.parseDouble(op1), Double.parseDouble(op2)));
        }
    }

    @Override
    public void enterTagStmt(FixRulesParser.TagStmtContext ctx) {
        List<FixRulesParser.TagContext> tags = ctx.tag();

        String operator = ctx.getParent().getChild(0).getText();
        String operand = ctx.getText();

        TagConcatenator concatenator = new TagConcatenator();
        for (FixRulesParser.TagContext t : tags) {
            concatenator.concat(t.INT().getText());
        }

        switch (operator) {
            case "equal to":
            case "=":
                builder.addCondition(new EqualsCondition(concatenator));
                break;
            default:
                System.out.println("unrecognized tag operator: " + operator);
        }
    }

    @Override
    public void enterTag(FixRulesParser.TagContext ctx) {
        System.out.println(ctx.getText());
    }

    @Override
    public void enterOnlyIf(FixRulesParser.OnlyIfContext ctx) {
        //  System.out.println("onlyIf");
    }

    //TODO
    @Override
    public void enterValid(FixRulesParser.ValidContext ctx) {
        builder.addCondition(new ValidCondition(builder.getTag()));
    }

    @Override
    public void enterIfRule(FixRulesParser.IfRuleContext ctx) {
        if (ifStack == null)
            ifStack = new Stack<>();

        String ifTagNumber = ctx.tag().INT().getText();
        GroovyTag ifTag = new GroovyTag(Integer.parseInt(ifTagNumber));
        GroovyRuleBuilder ifRuleBuilder = ifTag.getMustBe();

        GroovyRuleBuilder conditionalBuilder = builder.onlyIf(ifRuleBuilder);
        ifStack.push(conditionalBuilder);

        this.builder = ifRuleBuilder; //switch current builder
        this.tag = ifTag;
    }

    @Override
    public void exitIfRule(FixRulesParser.IfRuleContext ctx) {
        this.builder = ifStack.pop();
        this.tag = (GroovyTag) this.builder.getTag();
    }

    @Override
    public void enterMustBe(FixRulesParser.MustBeContext ctx) {
        builder = builder == null ? tag.getMustBe() : builder;
    }

    //TODO
    @Override
    public void enterMustNotBe(FixRulesParser.MustNotBeContext ctx) {
        builder = tag.getMustNotBe();
    }

    @Override
    public void enterIs(FixRulesParser.IsContext ctx) {
        builder = builder == null ? builder = tag.getIs() : builder;
    }

    private boolean conditionalStmt() {
        return ifStack != null;
    }

    @Override
    public void enterLogicalCondition(FixRulesParser.LogicalConditionContext ctx) {
        //System.out.println("logicalCondition:" + ctx.getText());
    }

    @Override
    public void enterMonoOperand(FixRulesParser.MonoOperandContext ctx) {
        ParserRuleContext parent = ctx.getParent();

        String operator = parent.getChild(0).getText();
        String operand = ctx.getText();

        operand = operand.replaceAll("\"", "");
        FieldTransformer transformed = TypeInferer.infer(operand);

        switch (operator) {
            case "match":
            case "~=":
                builder.addCondition(new PatternCondition(operand));
                break;
            case "equal to":
            case "=":
                builder.addCondition(new EqualsCondition(transformed));
                break;
            case "greater than":
            case ">":
                builder.greaterThan(Double.parseDouble(operand));
                break;
            case "less than":
            case "<":
                builder.lessThan(Double.parseDouble(operand));
                break;
            case "!=":
                builder.addCondition(new NotCondition(new EqualsCondition(transformed)));
                break;
            default:
                System.out.println("unrecognized mono operator: " + operator);
        }
    }

    @Override
    public void enterMonoOperandOperator(FixRulesParser.MonoOperandOperatorContext ctx) {
        //used by child
    }

    private boolean isPresent(FixRulesParser.LogicalOperatorContext logicalOperator) {
        return logicalOperator != null;
    }

    @Override
    public void enterAction(FixRulesParser.ActionContext ctx) {
    }

    @Override
    public void enterRule(FixRulesParser.RuleContext ctx) {
        String tagNumber = ctx.tag().INT().getText();
        this.tag = new GroovyTag(Integer.parseInt(tagNumber));
        builder = this.tag.getMustBe();
    }

    @Override
    public void exitRule(FixRulesParser.RuleContext ctx) {
        if (builder != null) {
            ruleBuilders.add(builder);
        }
    }

    public List<RuleBuilder> getRuleBuilders() {
        return ruleBuilders;
    }
}
