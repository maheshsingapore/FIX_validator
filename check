public class FixRulesBuilder extends FixRulesBaseListener {

    private GroovyRuleBuilder builder;
    private GroovyTag tag;
    List<Condition> conditions = new ArrayList<>();
    private List<RuleBuilder> ruleBuilders;

    @Override
    public void enterRules(FixRulesParser.RulesContext ctx) {
        ruleBuilders = new ArrayList<>();
    }

    @Override
    public void enterAbsent(FixRulesParser.AbsentContext ctx) {
        builder.getAbsent();
    }

    @Override
    public void enterPresent(FixRulesParser.PresentContext ctx) {
        builder.getPresent();
    }

    @Override
    public void enterAnd(FixRulesParser.AndContext ctx) {
        builder.getAnd();
    }

    @Override
    public void enterMandatory(FixRulesParser.MandatoryContext ctx) {
        builder.getMandatory();
    }

    @Override
    public void enterNumeric(FixRulesParser.NumericContext ctx) {
        builder.getNumeric();
    }

    @Override
    public void enterAlphanumeric(FixRulesParser.AlphanumericContext ctx) {
        builder.getNumeric();
    }

    @Override
    public void enterEveryRule(ParserRuleContext ctx) {
        //System.out.println("enterEveryRule: " + ctx.getText());
    }

    @Override
    public void enterList(FixRulesParser.ListContext ctx) {
        String listOperand = ctx.getText();
        String listOperator = ctx.getParent().getChild(0).getText();

        listOperand = listOperand.replaceAll("\\[|\\]|\"", "");
        String[] listOperands = listOperand.split(Patterns.COMMA_SEPARATOR);

        switch (listOperator) {
            case "not in":
                builder.addCondition(new NotCondition(new ContainsCondition(listOperands)));
                break;
            case "in":
                builder.oneOf(listOperands);
                break;
            default:
                System.out.println("unrecognized list operator: " + listOperator);
        }
    }

    @Override
    public void enterListOperator(FixRulesParser.ListOperatorContext ctx) {
        String listOperator = ctx.getText();
    }

    @Override
    public void enterBiOperand(FixRulesParser.BiOperandContext ctx) {
        String text = ctx.getText();
        text = text.replaceAll("\\)|\\(", "");

        String[] operands = text.split(Patterns.COMMA_SEPARATOR);
        if (operands != null && operands.length == 2) {
            String op1 = operands[0];
            String op2 = operands[1];

            builder.addCondition(new BetweenCondition(Double.parseDouble(op1), Double.parseDouble(op2)));
        }
    }

    @Override
    public void enterOnlyIf(FixRulesParser.OnlyIfContext ctx) {

        //System.out.println("onlyIf");
    }

    @Override
    public void enterMustBe(FixRulesParser.MustBeContext ctx) {
        builder = tag.getMustBe();
    }

    @Override
    public void enterMustNotBe(FixRulesParser.MustNotBeContext ctx) {
        builder = tag.getMustNotBe();
    }

    @Override
    public void enterIs(FixRulesParser.IsContext ctx) {
        builder = tag.getIs();
    }

    @Override
    public void enterLogicalCondition(FixRulesParser.LogicalConditionContext ctx) {
        FixRulesParser.OnlyIfContext onlyIfContext = ctx.onlyIf();
        //System.out.println("enterLogicalCondition:" + ctx.getText());
    }

    @Override
    public void enterMonoOperand(FixRulesParser.MonoOperandContext ctx) {
        ParserRuleContext parent = ctx.getParent();

        String operator = parent.getChild(0).getText();
        String operand = ctx.getText();

        operand = operand.replaceAll("\"", "");
        Object converted = Utils.convert(operand);

        switch (operator) {
            case "equal to":
            case "=":
                builder.addCondition(new EqualsCondition(converted));
                break;
            case "greater than":
            case ">":
                builder.greaterThan(Double.parseDouble(operand));
                break;
            case "less than":
            case "<":
                builder.lessThan(Double.parseDouble(operand));
                break;
            case "!=":
                builder.addCondition(new NotCondition(new EqualsCondition(converted)));
                break;
            default:
                System.out.println("unrecognized mono operator: " + operator);
        }
    }

    @Override
    public void enterMonoOperandOperator(FixRulesParser.MonoOperandOperatorContext ctx) {
        //used by child
    }

    private boolean isPresent(FixRulesParser.LogicalOperatorContext logicalOperator) {
        return logicalOperator != null;
    }

    @Override
    public void enterAction(FixRulesParser.ActionContext ctx) {
    }

    @Override
    public void enterRule(FixRulesParser.RuleContext ctx) {
        String tagNumber = ctx.tag().INT().getText();
        this.tag = new GroovyTag(Integer.parseInt(tagNumber));
        builder = this.tag.getMustBe();
    }

    @Override
    public void exitRule(FixRulesParser.RuleContext ctx) {
        if (builder != null) {
            ruleBuilders.add(builder);
        }
    }

    public List<RuleBuilder> getRuleBuilders() {
        return ruleBuilders;
    }
}
